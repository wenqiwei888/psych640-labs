<!DOCTYPE html>
<html>
<head>
  <title>Data Types and Structures In R</title>

  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />



  <meta name="date" content="2017-09-25" />

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'Data Types and Structures In R',
                        useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                      },

      // Author information
      presenters: [
            {
        name:  'William Hopper' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <link href="lib/ioslides-13.5.1/fonts/fonts.css" rel="stylesheet" />
  <link href="lib/ioslides-13.5.1/theme/css/default.css" rel="stylesheet" />
  <link href="lib/ioslides-13.5.1/theme/css/phone.css" rel="stylesheet" />
  <script src="lib/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
  <script src="lib/ioslides-13.5.1/js/prettify/prettify.js"></script>
  <script src="lib/ioslides-13.5.1/js/prettify/lang-r.js"></script>
  <script src="lib/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
  <script src="lib/ioslides-13.5.1/js/hammer.js"></script>
  <script src="lib/ioslides-13.5.1/js/slide-controller.js"></script>
  <script src="lib/ioslides-13.5.1/js/slide-deck.js"></script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }

  </style>

  <link rel="stylesheet" href="..\theme\css\custom.css" type="text/css" />

</head>

<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
            <p style="margin-top: 6px; margin-left: -2px;">2017-09-25</p>
          </hgroup>
  </slide>

<slide class=''><hgroup><h2>What is a data type?</h2></hgroup><article  id="what-is-a-data-type">

<ul>
<li>The data type of piece of information is defined by

<ul>
<li>how the information is represented in hardware (e.g., CPU, memory)</li>
<li>the range of values it can take on</li>
<li>the types of operations that can be performed with it in your software</li>
</ul></li>
<li>R uses many different data types, but the most important to learn are <strong>integer, double, character</strong>, and <strong>logical</strong>

<ul>
<li>These are the <strong>atomic</strong> data types in R, because they are the smallest possible building blocks</li>
</ul></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Integers &amp; Doubles</h2></hgroup><article  id="integers-doubles">

<ul>
<li>Just as in mathematics, the <strong>integer</strong> data type can only represent whole numbers

<ul>
<li>e.g. 6</li>
</ul></li>
<li>The <strong>double</strong> data type is used to represent all <a href='https://en.wikipedia.org/wiki/Real_number' title=''>real numbers</a> (e.g.,numbers with a fractional component).

<ul>
<li>e.g. 6.66666667</li>
</ul></li>
<li>However, the <strong>double</strong> data type is not perfectly precise, and numbers with a long decimal component must be approximated by the computer.</li>
<li>By default, R uses the <strong>double</strong> data type to represent the numbers you feed into it</li>
<li>Doubles and integers together are referred to as the &quot;numeric&quot; data types.</li>
</ul>

</article></slide><slide class=''><hgroup><h2>Character</h2></hgroup><article  id="character">

<ul>
<li>The <strong>character</strong> data type (sometimes referred to as the &quot;string&quot; data type) is used for representing textual data</li>
<li>To encode a string of text as character data in R, it must be wrapped in quotes (&quot; &quot; or &#39; &#39; are both acceptable)</li>
<li>Without the quotes, R will interpret the text as the name of an R object, and attempt to find that object and return its value. Missing quotes is a common source of &quot;object not found&quot; errors</li>
</ul>

<pre class = 'prettyprint lang-r'>a &lt;- &quot;foobar&quot;
a</pre>

<pre >## [1] &quot;foobar&quot;</pre>

<div class="errormsg">
<pre class = 'prettyprint lang-r'>a &lt;- foobar </pre>

<pre >## Error in eval(expr, envir, enclos): object &#39;foobar&#39; not found</pre></div>

</article></slide><slide class=''><hgroup><h2>Numbers as Numerics vs. Numbers as Characters</h2></hgroup><article  id="numbers-as-numerics-vs.-numbers-as-characters">

<ul>
<li>4.2 can be represented in R as both a character and a double. But, only in one case can mathematical operations be performed on them.</li>
</ul>

<div class="errormsg">
<pre class = 'prettyprint lang-r'>&quot;4.2&quot; + 1</pre>

<pre >## Error in &quot;4.2&quot; + 1: non-numeric argument to binary operator</pre></div>

<pre class = 'prettyprint lang-r'>4.2 + 1</pre>

<pre >## [1] 5.2</pre>

<p>This illustrates that practical differences between data types we care about are that some types do not support some operations (e.g. characters do not support math)</p>

</article></slide><slide class=''><hgroup><h2>Logical</h2></hgroup><article  id="logical">

<ul>
<li>Logical data can only take on 2 possible values: 1 (<code>TRUE</code>) or 0 (<code>FALSE</code>)</li>
<li>This type of datum is used to represent whether some state exists (is true) or does not exist (is false)</li>
<li><code>TRUE</code> and <code>FALSE</code> <em>must</em> be uppercased

<ul>
<li>can be abbreviated as <code>T</code> and <code>F</code>, but it is not recommended</li>
<li><code>T</code> and <code>F</code> can be over-written (e.g. <code>T &lt;- 2</code>)</li>
<li>But <code>TRUE</code> and <code>FALSE</code> are special and can never be overwritten</li>
</ul></li>
<li>This type of data will be more useful when we learn about data manipulation and program control flow.</li>
</ul>

</article></slide><slide class=''><hgroup><h2>Checking Data Types</h2></hgroup><article  id="checking-data-types">

<p>You can use the <code>typeof</code> function to see what data type an object holds.</p>

<pre class = 'prettyprint lang-r'>typeof(2)</pre>

<pre >## [1] &quot;double&quot;</pre>

<pre class = 'prettyprint lang-r'>typeof(2L) # L at the end makes an integer</pre>

<pre >## [1] &quot;integer&quot;</pre>

<pre class = 'prettyprint lang-r'>typeof(&quot;herp&quot;)</pre>

<pre >## [1] &quot;character&quot;</pre>

<pre class = 'prettyprint lang-r'>typeof(FALSE)</pre>

<pre >## [1] &quot;logical&quot;</pre>

</article></slide><slide class=''><hgroup><h2>Coercion</h2></hgroup><article  id="coercion">

<ul>
<li>Values stored in one data type can often be changed to another data type. This transformation is called <em>coercion</em></li>
</ul>

<pre class = 'prettyprint lang-r'>as.double(&quot;4.2&quot;) + 1</pre>

<pre >## [1] 5.2</pre>

<ul>
<li>Sometimes when an operation requires a specific data type, R will coerce things to the proper types for us.</li>
</ul>

<pre class = 'prettyprint lang-r'>TRUE + 1 # coerce TRUE to integer and add</pre>

<pre >## [1] 2</pre>

<ul>
<li>But things can&#39;t always be magically perfect</li>
</ul>

<div class="errormsg">
<pre class = 'prettyprint lang-r'>&quot;TRUE&quot; + 1</pre>

<pre >## Error in &quot;TRUE&quot; + 1: non-numeric argument to binary operator</pre></div>

</article></slide><slide class=''><hgroup><h2>Data Structures</h2></hgroup><article  id="data-structures" class="dslist">

<p>Of course, it is helpful in a language focused on analyzing data to have the ability to group multiple values together.</p>

<p>Think of data structures in R as big containers used for grouping together many values. After storing your data in these containers, you can reuse it multiple places (e.g. create an R object to store it) or access different subsets of it by position or name.</p>

In this course, we will primarily be working with 4 different types of data structures:

<style>
.dslist li {
    float:left;
    margin: 0 25px 0px 5px;
    padding: 15px 15px 0px 0px;    
}
</style>

<ol>
<li>Vectors</li>
<li>Matrices</li>
<li>Data Frames</li>
<li>Lists</li>
</ol>

</article></slide><slide class=''><hgroup><h2>Vectors</h2></hgroup><article  id="vectors">

<p>Vectors are 1 dimensional data structures which can hold numeric, logical, and character data.</p>

<p>Data types may not be mixed in a vector (e.g. you cannot have some elements be characters and other be integers)</p>

<p>The individual values held in the vector are referred to as <em>elements</em>, and vectors have a <em>length</em> equal to the number of elements it contains.</p>

<p>Vectors are the most basic data structures in R. In fact, all the scalar values we have worked with so far are represented internally by R as vectors of length 1!!</p>

</article></slide><slide class=''><hgroup><h2>Creating a vector</h2></hgroup><article  id="creating-a-vector">

<p>Vectors, no matter what type of data they hold, can be created by using the <code>c()</code> function in R, short for <em>concatenate</em>.</p>

<p>Just place each value you want to be included in the vector inside the parenthesis, separated with a comma.</p>

<pre class = 'prettyprint lang-r'>new_vector &lt;- c(1,10,45,-1)
char_vector &lt;- c(&quot;foo&quot;,&quot;bar&quot;,&quot;herp&quot;,&quot;derp&quot;)</pre>

<p><code>c()</code> can combine existing vectors as well, not just create new ones.</p>

<pre class = 'prettyprint lang-r'>c(new_vector,c(1,2,3,4,5))</pre>

<pre >## [1]  1 10 45 -1  1  2  3  4  5</pre>

</article></slide><slide class=''><hgroup><h2>Vector Tricks</h2></hgroup><article  id="vector-tricks">

<p>You can create a sequential numeric vector using the colon operator <code>:</code>, instead of typing out hundreds or thousands of values by hand.</p>

<pre class = 'prettyprint lang-r'>55:100</pre>

<pre >##  [1]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71
## [18]  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88
## [35]  89  90  91  92  93  94  95  96  97  98  99 100</pre>

<p>Sequences of other step sizes can be made with the <code>seq()</code> function</p>

<pre class = 'prettyprint lang-r'>seq(from = 5, to = 22, by = 3)</pre>

<pre >## [1]  5  8 11 14 17 20</pre>

</article></slide><slide class=''><hgroup><h2>Element-wise Math operations</h2></hgroup><article  id="element-wise-math-operations">

<p>You can apply the math operators we used in the first class to vectors as well. When you add, divide, multiply, or subtract a set of vectors, R matches the vectors up by position and applies the operation to each pair of elements.</p>

<pre class = 'prettyprint lang-r'>vec1 &lt;- c(5,-1,100,75)
vec2 &lt;- c(10,3,4,-4)
vec2 + vec1</pre>

<pre >## [1]  15   2 104  71</pre>

<pre class = 'prettyprint lang-r'>vec2 * vec1</pre>

<pre >## [1]   50   -3  400 -300</pre>

<p>So, the first element of <code>vec1</code> gets added to the first element of <code>vec2</code>, etc&#8230;</p>

<p>If you want to find the grand sum or product of all the elements in a numeric vector, use the <code>sum()</code> and <code>prod()</code> functions, respectively.</p>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity">

<ol>
<li>Try to create a vector that uses all the 4 basic data types. What type of data is stored in the resulting vector?</li>
<li>Take <code>vec1</code> and <code>vec2</code> you created earlier and concatenate them together, and find the grand sum.</li>
</ol>

</article></slide><slide class=''><hgroup><h2>Matrices</h2></hgroup><article  id="matrices">

<p>Matrices in R are the same as matrices from linear algebra, with the notable difference of being able to hold non-numeric types of data.</p>

<p>They are a rectangular 2-D data structure, meaning that the number of elements in the matrix must be equal to the product of the number of rows and the number of columns.</p>

<ul>
<li>rows = dimension 1</li>
<li>columns = dimension 2</li>
</ul>

<p>Like vectors, data types may <em>not</em> be mixed in a matrix (e.g. you cannot have some elements be characters and other be numeric, etc.)</p>

</article></slide><slide class=''><hgroup><h2>Creating Matrices</h2></hgroup><article  id="creating-matrices">

<p>A matrix is created by feeding a vector into the <code>matrix()</code> function, and specifying either the number of rows <em>or</em> number of columns, <em>or</em> both.</p>

<pre class = 'prettyprint lang-r'>wide &lt;- matrix(c(1:3,99:101),ncol=3)
wide</pre>

<pre >##      [,1] [,2] [,3]
## [1,]    1    3  100
## [2,]    2   99  101</pre>

<pre class = 'prettyprint lang-r'>long &lt;- matrix(c(1:3,99:101),nrow=3)
long</pre>

<pre >##      [,1] [,2]
## [1,]    1   99
## [2,]    2  100
## [3,]    3  101</pre>

</article></slide><slide class=''><hgroup><h2>Creating Matrices</h2></hgroup><article  id="creating-matrices-1">

<p>If you want a large matrix but with only a few unique values, take advantage of R&#39;s ability to <strong>recycle</strong> input.</p>

<pre class = 'prettyprint lang-r'>matrix(c(4),nrow=3, ncol=10)</pre>

<pre >##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    4    4    4    4    4    4    4    4    4     4
## [2,]    4    4    4    4    4    4    4    4    4     4
## [3,]    4    4    4    4    4    4    4    4    4     4</pre>

<p>Note the matrix is filled up by column (i.e. first element goes to row 1 column 1, second element goes to row 2, column 1, etc.)</p>

<pre class = 'prettyprint lang-r'>matrix(c(4,0), nrow=2, ncol=10)</pre>

<pre >##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    4    4    4    4    4    4    4    4    4     4
## [2,]    0    0    0    0    0    0    0    0    0     0</pre>

</article></slide><slide class=''><hgroup><h2>Matrix Operations</h2></hgroup><article  id="matrix-operations">

<p>You can inspect the dimensionality of a matrix (or any R object) with the <code>dim</code> function.</p>

<pre class = 'prettyprint lang-r'>dim(long) # 3 by 2</pre>

<pre >## [1] 3 2</pre>

<pre class = 'prettyprint lang-r'>dim(wide) # 2 by 3</pre>

<pre >## [1] 2 3</pre>

<p>You can get the total number of elements in the matrix by multiplying these numbers</p>

<pre class = 'prettyprint lang-r'>prod(dim(wide))</pre>

<pre >## [1] 6</pre>

</article></slide><slide class=''><hgroup><h2>Matrix Math</h2></hgroup><article  id="matrix-math">

<p>When doing math on matrices with the <code>+</code>, <code>*</code>, <code>/</code> or <code>-</code> operators, R will by default applies the operations element-wise (i.e., add the first element of one matrix to the first element of the other matrix, etc.).</p>

<p>But you can perform matrix multiplication with the <code>%*%</code> operator.</p>

<pre class = 'prettyprint lang-r'>long %*% wide</pre>

<pre >##      [,1]  [,2]  [,3]
## [1,]  199  9804 10099
## [2,]  202  9906 10300
## [3,]  205 10008 10501</pre>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity-1">

<p>Try creating a matrix with 900 elements and 9 columns that contains only logical <code>TRUE</code>s. Confirm the dimensionality using R.</p>

</article></slide><slide class=''><hgroup><h2>Data Frames</h2></hgroup><article  id="data-frames">

<p>Like matrices, Data Frames are are 2D, rectangular data structures, but are more flexible because they allow for different data types to be stored in each column.</p>

<p>A Data Frame is usually the best way to store and work with data that mixes qualitative and quantitative variables.</p>

</article></slide><slide class=''><hgroup><h2>Creating Data Frames</h2></hgroup><article  id="creating-data-frames">

<p>Data frames can be created by passing <code>name = value</code> pairs to the <code>data.frame()</code> function. The values should be vectors (of any type) and the names should be unquoted strings of text, which will be used to label each column. Importantly, all the vectors stored in the data frame must be of <em>identical length</em>.</p>

<p>Essentially, a data frame is a container that imposes a relational structure on a set of vectors.</p>

<pre class = 'prettyprint lang-r'>df &lt;- data.frame(x=c(1,4,4,2), y=c(3,3,1,4),
                 month=c(&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Jan&quot;),
                 stringsAsFactors = FALSE)
df</pre>

<pre >##   x y month
## 1 1 3   Sep
## 2 4 3   Oct
## 3 4 1   Nov
## 4 2 4   Jan</pre>

</article></slide><slide class=''><hgroup><h2>stringsAsFactors?</h2></hgroup><article  id="stringsasfactors">

<p>This example also shows an extra argument, <code>stringsAsFactors = FALSE</code>, that was <strong>not</strong> a variable to store in the data frame. This argument controls how R interprets character vectors (a.k.a. strings) when forming the data frame.</p>

<p>If <code>stringsAsFactors = TRUE</code>, the default setting, then R converts your character vector to a <strong>factor</strong> variable in the data frame.</p>

<p>A factor variable is a class of vector where <em>all</em> the possible values are known and already included in the vector. A good example of a factor variable would be the gender responses to a survey where there was a box for male, and a box for female; there are only 2 possible values the data can take on, and you know them to be valid a-priori.</p>

<p>If <code>stringsAsFactors = FALSE</code>, then R leaves the input data alone when forming the data frame.</p>

</article></slide><slide class=''><hgroup><h2>stringsAsFactors?</h2></hgroup><article  id="stringsasfactors-1">

<p>What should you use?</p>

<p>99% of the time, you&#39;ll want your data frame to have a plain old character vector for a variable. They&#39;re inherently more flexible, and if you decide later you <em>do</em> want a factor variable, you can always convert it into one with the <code>factor()</code> function.</p>

<p>So, get into the habit of specifying <code>stringsAsFactors = FALSE</code> when you use functions that create data frames (e.g., <code>data.frame()</code>, <code>read.csv()</code>, <code>read.table()</code>, etc.)</p>

<p>Or, you can change the setting globally for the length of your R session by using <code>options(stringsAsFactors = FALSE</code>).</p>

<p>If you want to know more about the reasons for all this nonsense, <a href='https://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/' title=''>stringsAsFactors: An unauthorized biography</a> and <a href='http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh' title=''>stringsAsFactors = <sigh></a> are two great reads.</p>

</article></slide><slide class=''><hgroup><h2>Data Frame Tricks (and Traps)</h2></hgroup><article  id="data-frame-tricks-and-traps">

<p>The <code>data.frame()</code> function can also recycle input, so you can save some keystrokes if you have a column that has only a few unique values that repeat.</p>

<p>R compares the length of the first vector to the length of each vector after it. If the lengths don&#39;t match, R will check if the length of one vector is a multiple of the length of the other vector.</p>

<p>If so, R will repeat the shorter vector over and over so the lengths match up. In this example, the <code>x</code> variable has length 4, and the <code>month</code> vector has length 1; since 4 is a multiple of 1 (1 x 4 = 4), R will repeat the <code>month</code> vector 4 times so the lengths match.</p>

<pre class = 'prettyprint lang-r'>data.frame(x=c(1,4,4,2),y=c(3,3,1,4),month=&quot;Sep&quot;)</pre>

<pre >##   x y month
## 1 1 3   Sep
## 2 4 3   Sep
## 3 4 1   Sep
## 4 2 4   Sep</pre>

</article></slide><slide class=''><hgroup><h2>Data Frame Tricks (and Traps)</h2></hgroup><article  id="data-frame-tricks-and-traps-1">

<p>The <code>data.frame()</code> function will throw an error if the length of the longer vector is not a multiple of the shorter vector&#39;s lengths.</p>

<p>Here, the <code>x</code> variable still has length 4, but the <code>month</code> vector has length 3; since 4 is not multiple of 3, an error occurs.</p>

<div class="errormsg">
<pre class = 'prettyprint lang-r'>data.frame(x=c(1,4,4,2),y=c(3,3,1,4),
           month=c(&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;)) </pre>

<pre >## Error in data.frame(x = c(1, 4, 4, 2), y = c(3, 3, 1, 4), month = c(&quot;Sep&quot;, : arguments imply differing number of rows: 4, 3</pre></div>

<p>Recycling enables concise code, but can make for hard to spot bugs when you didn&#39;t intended for recycling to happen. Use this feature with care, and favor being explicit about your vector lengths when programming.</p>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity-2">

<p>Create a data frame that has:</p>

<ol>
<li>Rows for you and your neighbor(s)</li>
<li>Columns to hold your first names, last names, birthday, and age.</li>
</ol>

</article></slide><slide class=''><hgroup><h2>Lists</h2></hgroup><article  id="lists">

<p>Lists are the most abstract and flexible data structure in R. Lists can hold any type of R object, but doesn&#39;t impose any relationship between them.</p>

<p>You can have a list holding matrices, data frames, vectors, and even lists holding other lists!</p>

</article></slide><slide class=''><hgroup><h2>Lists</h2></hgroup><article  id="lists-1">

<p>Think of lists like a folder on your hard drive.</p>

<p>You can stuff any kind of file you like in there and give it a name, but there is no relationship between them inside that folder, other than the order they are sorted in.</p>

<p>Use a list when you need to group data structures of different sizes and types together. But carefully consider if there is another way, because the lack of structured relationships between the data in different list elements can make them tricky to work with</p>

</article></slide><slide class=''><hgroup><h2>Creating Lists</h2></hgroup><article  id="creating-lists">

<p>As you might have guessed, you can create lists of your own with the <code>list()</code> function.</p>

<p>Like the <code>data.frame()</code> function, you pass in <code>name=value</code> pairs. But now, the values can be any R object, of any size, not just vectors with the same lengths.</p>

<pre class = 'prettyprint lang-r'>biglist &lt;- list(first = -10:-15, second = data.frame(x=c(&quot;A&quot;,&quot;B&quot;), y = 1:2))
biglist</pre>

<pre >## $first
## [1] -10 -11 -12 -13 -14 -15
## 
## $second
##   x y
## 1 A 1
## 2 B 2</pre>

</article></slide><slide class=''><hgroup><h2>List Tips</h2></hgroup><article  id="list-tips">

<ul>
<li>Avoid nesting lists if you can. One level of nesting is usually all right, but more than 1 is pain.</li>
<li>Use the <code>str()</code> function to examine the structure of the list if you&#39;re having problems working with it. This function will tell you useful information about any R object&#39;s internal structure, such as the class of the data structure and data types it hold, all the unique values in it, etc.</li>
</ul>

<pre class = 'prettyprint lang-r'>str(biglist)</pre>

<pre >## List of 2
##  $ first : num [1:4] 1 10 45 -1
##  $ second: int [1:2, 1:3] 1 2 3 99 100 101</pre>

</article></slide><slide class=''><hgroup><h2>Exercises</h2></hgroup><article  id="exercises">

<ol>
<li>Make a list of length 3, where each element is a data structure with more than one element. Each element of the list must be named.</li>
<li>report the details of this lists structure, and the structure of the objects it holds, using an R function.</li>
</ol>

<p>*Hint: reuse some of the data structures you&#39;ve created in the previous exercises as your list elements.</p>

</article></slide><slide class=''><hgroup><h2>Advanced Extras</h2></hgroup><article  id="advanced-extras">

</article></slide><slide class=''><hgroup><h2>Names</h2></hgroup><article  id="names">

<p>After you create a vector, you can give the elements names, using the <code>names()</code> function, and a character vector. This can be useful later when you want to pick out a few values from the larger vector.</p>

<pre class = 'prettyprint lang-r'>names(new_vector) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)</pre></article></slide>


  <slide class="backdrop"></slide>

</slides>


<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
