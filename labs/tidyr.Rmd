---
title: "Reshaping Datasets with reshape2"
author: "William Hopper"
date: "`r Sys.Date()`"
output:
  ioslides_presentation:
    css: ["../theme/css/custom.css", "../theme/css/tidyCellHighlighting.css"]
---

```{r setup,echo=FALSE,message=FALSE,warning=FALSE}
library(pander)
library(tidyr)
library(dplyr)
library(whoppeR)
knitr::opts_chunk$set("warning"=FALSE, "message"=FALSE, cache = TRUE)
```

## Reshaping with `tidyr`
The tools from the `tidyr` package help you re-arrange tabular data stored in data frames, with an emphasis on helping you *normalize* datasets.

There are 4 main functions for re-arranging data in the `tidyr` package:

1. `gather()`: transforms data from wide(r) to long(er)
2. `spread()`: transforms data from long(er) to wide(r)
3. `separate()`: splits a single column into multiple columns
4. `unite()`: combines multiple columns into a single column

## The temperature data
We'll demonstrate how to use each function with a small dataset first, so its easy to see what changes get made. So, install `tidyr`, and load the [temperature dataset](../data/temperature.csv).

```{r, eval=FALSE, cache=FALSE}
install.packages("tidyr")
library(tidyr)
temperature <- read.csv("https://wjhopper.github.io/psych640/data/temperature.csv")
temperature
```

```{r import_temp_data, echo=FALSE, cache=FALSE}
temperature <- read.csv("../data/temperature.csv")
tmp_initial <- temperature
```
```{r display_temp_data, echo=FALSE}
pander(temperature, "High Temperatures (Farenheight)")
```

## The temperature data
```{r, ref.label="display_temp_data", echo=FALSE}
pander(temperature, "High Temperatures (Farenheight)")
```

The `temperature` dataset has measurements of 3 variables: **City**, **Date**, and **Temperature**.

But the layout of the dataset is non-normalized, because values of the **Date** variable (Feb_19_2017, Feb_18_2017, and Feb_17_2017) are used as unique variables themselves.

Instead, the dates *should* be in the cells of the table as values of the **Date** variable.

## The `gather()` function 
Let's use the `gather` function to move the dates that are being used as column headers down into the table under a new variable **date**, and move the actual temperature measurements into a new variable called **temp**.

`gather` takes 4 required arguments:

1. `data`: the name of the data frame to re-arrange
2. `key`: the name of the to-be-created variable that will hold values currrently used as variables
3. `value`: the name of the to-be-created variable that will hold the values currently present as observations in variables to be gathered.
4. `...`: A bare list of columns to gather (or columns *not* to gather)


## The `gather()` function 
Let's make this more specific to our situation.

```{r,eval=FALSE}
gather(data = temperature,
       key = "date",
       value = "temp",
       -city)
```

- The `key` column will be named "date", because it will hold the dates that were previously used as individual variables
- The `value` column will be named "temp" because the values in each of the Feb_19_2017, Feb_18_2017, and Feb_17_2017 variables were our actual temperature measurements.
- We want to gather values in all the colums *except* the city column, so we can write `-city`. Alternatively, we could write `Feb_19_2017, Feb_18_2017, and Feb_17_2017`.

## The `gather()` function {#gather  .sothis}
So this:
```r
temperature <- gather(data = temperature, key = "date", value = "temp", -city)
```
turns this:
```{r, echo=FALSE}
pander(temperature)
```

into this:

```{r, echo=FALSE}
temperature <- gather(data = temperature, key = "date", value = "temp", -city)
pander(temperature)
```


## The `gather()` function {#gather2}
Critically, the temperature observations are still matched up with the same date!

```{r, echo=FALSE}
pander(tmp_initial) 
```

```{r, echo=FALSE}
pander(temperature)
```


## The `spread()` function
The `spread` function is the complement to the `gather` function, so we can use it to undo this transformation. 

Its job is to takes values from an existing variable in the dataset and "spread" them out, creating a new variable for each unique value in the old variable.

The `spread` function takes 3 required arguments:

1. `data`: the name of the data frame to re-arrange
2. `key`: the name of the existing variable whose *N* unique values will be "spread out" into *N* new variables
3. `value`: the name of the existing variable whose values will be used as observations in the *N* to-be-created variables.

## The `spread()` function
So to undo the wider-to-longer normalization we just performed, we would use this function call:

```{r,eval=FALSE}
spread(data = temperature,
       key = "date",
       value = "temp")
```

- the `key` argument is the "date" column, because the "date" column holds the values we want to be new variables
- the `value` argument is the "temp" column, because we want the temperature measurements to be observations in the 3 date variables

We don't have to specify the names of the new variable we're creating, because they are going to come from the values in the "date" variable.

## The `spread()` function {#spread  .sothis}
So this:
```r
spread(data = temperature, key = "date", value = "temp")
```
turns this:
```{r, echo=FALSE}
pander(temperature)
```

into this:

```{r, echo=FALSE}
pander(spread(data = temperature, key = "date", value = "temp"))
```

## The `separate()` function
The `separate` function is used to transform one variable in your dataset into many variables in your dataset.
This is useful when multiple variables have been concatenated into a single variable, and you would like to examine these variables separately.

For example, in our normalized `temperature` dataset, the `date` variable is actually a combination of a month, day of month, and year variable, concatenated together.

```{r, echo=FALSE}
pander(temperature)
```

## The `separate()` function
Let's separate this amalgamated "date" variable into 3 different variables, one for the month, day, and year.

The `separate` function has 3 required arguments, and a 4^th^ optional argument you almost always want to specify.

1. `data`: the name of the data frame to re-arrange
2. `col`: the bare name of the variable to be split-up
3. `into`: a character vector of names for the to-be-created variables
4. `sep`: the delimiter defining how to split existing values into multiple new values. 

By default, `separate` will split the values in the `col` variable on any non-alphanumeric character (e.g., `_`,  `-`, `.`, `:`, etc.). You can have it split on a character string, a numeric index (e.g., every 3^rd^ character), or using a regular expression.

## The `separate()` function
In our case, we would use the separate function like so:
```{r separate, eval=FALSE}
separate(data = temperature,
         col = date,
         into = c("month", "day", "year"),
         sep = "_")
```

- We want to separate the `col`umn named `date` *into* 3 new variables named "month", "day", and "year"
- We are going to find the values that should go into the month, day, and year variables by splitting up the values in the `date` variable at every underscore character.

## The `separate()` function {#separate .sothis}
So this:
```r
temperature <- separate(temperature, col=date, into=c("month", "day", "year"), sep = "_")
```

turns this:
```{r, echo=FALSE}
pander(prettifyTable(temperature, rows = 3))
```

into this:
```{r, echo=FALSE}
temperature <- separate(temperature, col=date, into=c("month", "day", "year"), sep = "_")
pander(prettifyTable(temperature, rows = 3))
```

## The `unite()` function
The `unite` function is the complement to the separate function. As you can imagine, its job is to combine multiple variables into a single variable. 

The `unite` function has 3 required arguments, and 2 other arguments you often want to specify:

1. `data`: the name of the data frame to re-arrange
2. `col`: the bare name of the to-be-created amalgam variable
3. `...` : a list of bare columns whose values are to be combined row-wise and placed inside the new variable `col`
4. `sep`: the separator to use between combined values (defaults to `"_"`).
5.  remove`: a logical value indicating whether or not to remove the input columns from the data frame after combining them (defaults to `TRUE`).

## The `unite()` function {.sothis}
So to undo our separation of the `date` variable, we could use this:
```r
unite(temperature, col=date, month, day, year)
```

to turn this:
```{r, echo=FALSE}
pander(prettifyTable(temperature, rows = 3))
```

back into this:
```{r, echo=FALSE}
pander(prettifyTable(unite(temperature,
                           col=date,
                           month, day, year),
                     rows = 3))
```

## Resources
- A general, modern framework for tidy data
    - [Short intro](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)
    - [Full Paper](http://vita.had.co.nz/papers/tidy-data.html)