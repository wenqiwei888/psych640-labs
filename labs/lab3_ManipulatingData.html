<!DOCTYPE html>
<html>
<head>
  <title>Manipulating Data Part 1: The Data Awakens</title>

  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />



  <meta name="date" content="2016-10-04" />

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <link rel="stylesheet" media="all" href="lib/ioslides-13.5.1/fonts/fonts.css">

  <link rel="stylesheet" media="all" href="lib/ioslides-13.5.1/theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="lib/ioslides-13.5.1/theme/css/phone.css">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'Manipulating Data Part 1: The Data Awakens',
                        useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                      },

      // Author information
      presenters: [
            {
        name:  'William Hopper' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }

  </style>

  <link rel="stylesheet" href="../theme/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../theme/css/ManipulatingData.css" type="text/css" />


</head>

<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
            <p style="margin-top: 6px; margin-left: -2px;">2016-10-04</p>
          </hgroup>
  </slide>

<slide class=''><hgroup><h2>Indexing</h2></hgroup><article  id="indexing">

<p>All throughout your data analysis pipeline, you will face the need to take smaller chunks out of a larger data structure. Sometimes you will need to change the data that is stored in your structure, or use it as input to another function, or perhaps you need to plot it.</p>

<p>The task of slicing a smaller chunk out of a larger data structure is called <strong>indexing</strong> in R (sometimes called <strong>subsetting</strong> depending on context), and is performed using the square bracket characters <code>[]</code>.</p>

</article></slide><slide class=''><hgroup><h2>Indexing &#39;Ingredients&#39;</h2></hgroup><article  id="indexing-ingredients">

<p>Indexing a data structure in R requires 4 ingredients.</p>

<ol>
<li>An R object that supports indexing

<ul>
<li>e.g. A data frame, matrix, vector or list</li>
</ul></li>
<li>An opening square bracket <code>[</code></li>
<li>1 (or more) vectors which indicate which values from the larger data structure should be pulled out.</li>
<li>a closing square bracket <code>]</code></li>
</ol>

<p>Arrange the ingredients in an R expression like so:</p>

<p><code>DataStructure[IndexVector]</code></p>

<p>We will focus on learning what can go inside the square brackets for different types of R data structures</p>

</article></slide><slide class=''><hgroup><h2>Indexing Vectors</h2></hgroup><article  id="indexing-vectors">

<p>Broadly, there are 2 types of indexing vectors that are useful inside the square brackets.</p>

<ol>
<li>Numeric Vectors

<ul>
<li>e.g. <code>c(1,4,5,6,10)</code></li>
</ul></li>
<li>Logical Vectors

<ul>
<li>e.g. <code>c(TRUE,FALSE,FALSE,TRUE)</code></li>
</ul></li>
</ol>

<p>We&#39;ll start with numeric indexing vectors to get a feel for the general procedure, and move up to logical indexing.</p>

</article></slide><slide class=''><hgroup><h2>Numeric Index Vectors</h2></hgroup><article  id="numeric-index-vectors">

<p>We&#39;ll start by slicing smaller chunks out of a larger vector. Here, the numeric vectors inside the brackets tell R the <em>positions</em> of the elements we wish to extract.</p>

<pre class = 'prettyprint lang-r'>&gt; alphabet &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,
... +                &quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) 
&gt; alphabet[c(1,26)] # Extract First and 26th element</pre>

<pre >## [1] &quot;a&quot; &quot;z&quot;</pre>

<pre class = 'prettyprint lang-r'>&gt; alphabet[10:20] # Extract tenth through 20th</pre>

<pre >##  [1] &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot;</pre>

<pre class = 'prettyprint lang-r'>&gt; alphabet[seq(from=1,to=26,by=2)] # Extract every other element</pre>

<pre >##  [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot;</pre>

</article></slide><slide class=''><hgroup><h2>Common Errors with Numeric Indices</h2></hgroup><article  id="common-errors-with-numeric-indices">

<p>The most common mistake is including a value in your indexing vector which is greater than the length of the vector you are subsetting</p>

<pre class = 'prettyprint lang-r'>&gt; alphabet[100] # there are not 100 letters in the alphabet</pre>

<pre >## [1] NA</pre>

<p>The <code>NA</code> means the value is missing. This is commonly referred to as an &quot;index out of bounds&quot; error.</p>

Another common mistake is forgetting to concatenate the values you want to use for the indexing vector (i.e. forgetting the <code>c()</code> function).

<div class="errormsg">
<pre class = 'prettyprint lang-r'>&gt; alphabet[1,5,10]</pre>

<pre >## Error in alphabet[1, 5, 10]: incorrect number of dimensions</pre></div>

</article></slide><slide class=''><hgroup><h2>Indexing Tricks</h2></hgroup><article  id="indexing-tricks">

<p>Instead of creating a vector of values you <em>do</em> want to pick out, it may be easier to come up with a vector of ones you <em>don&#39;t</em> want. We can use negative number&#39;s to specify which vector elements we don&#39;t want.</p>

<pre class = 'prettyprint lang-r'>&gt; alphabet[c(-1,-26)] # Same as alphabet[2:24]</pre>

<pre >##  [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot;
## [18] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot;</pre>

<pre class = 'prettyprint lang-r'>&gt; alphabet[-1:-10]</pre>

<pre >##  [1] &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot;</pre>

<p>Indexing with positive vectors is usually preferred, as the intent of the code is more clear, but sometimes this is easier and more clear (e.g. when dropping the first or last value)</p>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity">

<p>Execute the following code and look at the values in <code>months</code>:</p>

<pre class = 'prettyprint lang-r'>months &lt;- c(&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
            &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;)
months</pre>

<pre >##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;      
##  [6] &quot;June&quot;      &quot;July&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;  
## [11] &quot;November&quot;  &quot;December&quot;</pre>

<p>Now, do the following:</p>

<ol>
<li>Index <code>months</code> to pull out <code>&quot;February&quot;</code> and <code>&quot;March&quot;</code></li>
<li>Index <code>months</code> to pull out every third month</li>
</ol>

</article></slide><slide class=''><hgroup><h2>Logical Indexing</h2></hgroup><article  id="logical-indexing">

<p>When performing logical indexing, you supply a vector specifying whether to extract a specific element (with a <code>TRUE</code>) or to <em>not</em> extract a specific element (with a <code>FALSE</code>).</p>

<p>Let&#39;s revisit the example of selecting the first and last elements of the alphabet vector: We make a vector of logicals and stick it in the square brackets after your vector.</p>

<pre class = 'prettyprint lang-r'>&gt; alphabet[c(1,26)]</pre>

<pre >## [1] &quot;a&quot; &quot;z&quot;</pre>

<pre class = 'prettyprint lang-r'>&gt; alphabet[c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
... +             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
... +             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE)]</pre>

<pre >## [1] &quot;a&quot; &quot;z&quot;</pre>

</article></slide><slide class=''><hgroup><h2>Logical Indexing</h2></hgroup><article  id="logical-indexing-1">

<p>But this specific example is not a good use case for logical vectors. Why?</p>

<ol>
<li>Longer Code: length of the logical vector must match the length of the object its subsetting.</li>
<li>Duplicating work: If you already know the position of the elements you want, just put them into a vector and you&#39;re done!</li>
</ol>

<p>The logical vector&#39;s utility comes into play when you <em>don&#39;t</em> know the numeric positions of the elements you are interested in.</p>

</article></slide><slide class=''><hgroup><h2>Logical Indexing</h2></hgroup><article  id="logical-indexing-2">

<p>&quot;But wait&quot; you say: &quot;If we don&#39;t know where they are already, how are we going to find them?&quot;. This brings us to <strong>logical testing</strong> and <strong>relational operators</strong></p>

<p>Relational operators are R expressions that can be used to test whether or not some value meets a condition or not. If it meets your test&#39;s conditions, the test returns <code>TRUE</code>. If it does not, it returns <code>FALSE</code>.</p>

<p>You already know lots of relational operators. The equal to, greater than and less than expressions from 3rd grade math are all relational operators!</p>

</article></slide><slide class=''><hgroup><h2>Relational Operators Table</h2></hgroup><article  id="relational-operators-table">

<table class = 'rmdtable'>
<tr class="header">
<th align="left">Comparison</th>
<th align="left">Expression</th>
<th align="left">Example</th>
</tr>
<tr class="odd">
<td align="left">Less Than</td>
<td align="left"><code>&lt;</code></td>
<td align="left"><code>5 &lt; 10</code>, <code>5 &lt; 1</code></td>
</tr>
<tr class="even">
<td align="left">Less Than or Equal To</td>
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>5 &lt;= 5</code>, <code>5 &lt;= 1</code></td>
</tr>
<tr class="odd">
<td align="left">Greater Than</td>
<td align="left"><code>&gt;</code></td>
<td align="left"><code>10 &gt; 5</code>, <code>5 &gt; 5</code></td>
</tr>
<tr class="even">
<td align="left">Greater Than or Equal To</td>
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>10 &gt;= 10</code>, <code>10 &gt;= 12</code></td>
</tr>
<tr class="odd">
<td align="left">Equal To</td>
<td align="left"><code>==</code></td>
<td align="left"><code>5 == 6</code>, <code>5 == 5</code></td>
</tr>
<tr class="even">
<td align="left">Not equal to</td>
<td align="left"><code>!=</code></td>
<td align="left"><code>5 != 6</code>, <code>5 != 5</code></td>
</tr>
</table>

</article></slide><slide class=''><hgroup><h2>Relational Operators &amp; Indexing</h2></hgroup><article  id="relational-operators-indexing">

<p>What makes relational operators useful is that they can be applied to all the elements of a data structure simultaneously.</p>

<pre class = 'prettyprint lang-r'>&gt; x &lt;- 2:11
&gt; x &lt;= 5 # Apply the less than or equals test</pre>

<pre >##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE</pre>

<p>As you can see, values that meet the criteria (&lt;= 5) return as <code>TRUE</code>.</p>

<pre class = 'prettyprint lang-r'>&gt; x[x &lt;= 5] # Index vector x with the results of the test. </pre>

<pre >## [1] 2 3 4 5</pre>

<p>When this logical vector is used to index the vector <code>x</code>, only the elements where the logical vector has value <code>TRUE</code> are returned.</p>

</article></slide><slide class=''><hgroup><h2>Relational Operators &amp; Indexing</h2></hgroup><article  id="relational-operators-indexing-1">

<p>We index character vectors using the <code>==</code> and <code>!=</code> operators, but not the greater/less than operators. Quantity makes no sense for characters!</p>

<pre class = 'prettyprint lang-r'>&gt; months == &quot;June&quot; # The sixth element is TRUE</pre>

<pre >##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE</pre>

<pre class = 'prettyprint lang-r'>&gt; months[months == &quot;June&quot;]</pre>

<pre >## [1] &quot;June&quot;</pre>

<pre class = 'prettyprint lang-r'>&gt; months[months != &quot;July&quot;]</pre>

<pre >##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;      
##  [6] &quot;June&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;   &quot;November&quot; 
## [11] &quot;December&quot;</pre>

</article></slide><slide class=''><hgroup><h2>Other Useful Tests: <code>is.na()</code></h2></hgroup><article  id="other-useful-tests-is.na">

<p>Unfortunately, we often have to deal with missing observations in real world data sets. R codes missing data as <code>NA</code> (or sometimes <code>NaN</code>). We can use the <code>is.na()</code> function to find any missing values in a vector.</p>

<pre class = 'prettyprint lang-r'>&gt; missingno &lt;- c(10,NA,1,4,2,NA,NA,99,NaN, NA)
&gt; is.na(missingno)</pre>

<pre >##  [1] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE</pre>

<pre class = 'prettyprint lang-r'>&gt; missingno[!is.na(missingno)] # Select things that are the opposite of missing</pre>

<pre >## [1] 10  1  4  2 99</pre>

</article></slide><slide class=''><hgroup><h2>Other Useful Tests: modulus division</h2></hgroup><article  id="other-useful-tests-modulus-division">

<p>An important arithmetic operator that was not mentioned last week is the modulus operator <code>%%</code>, which gives us the remainder of division.</p>

<p>For example: <code>5 %% 3</code> is <code>2</code>.</p>

<pre class = 'prettyprint lang-r'>&gt; lisa &lt;- c(34, 509, 63, 187, 998, 78, 3330)
&gt; lisa %% 17 == 0</pre>

<pre >## [1]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE</pre>

<pre class = 'prettyprint lang-r'>&gt; lisa[lisa %% 17 == 0]</pre>

<pre >## [1]  34 187</pre>

<p>This returns all the values of the vector called <code>lisa</code> that are multiples of 17, since multiples of 17 will have a remainder of zero.</p>

</article></slide><slide class=''><hgroup><h2>Tips and Tricks</h2></hgroup><article  id="tips-and-tricks">

<p>A useful function to know is <code>which()</code>. When used on a logical vector, it will return to your the position indices of the vector&#39;s <code>TRUE</code> element. It is useful when you want to know <strong>where</strong> in the vector your matches occur.</p>

<pre class = 'prettyprint lang-r'>&gt; lisa %% 17 == 0</pre>

<pre >## [1]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE</pre>

<pre class = 'prettyprint lang-r'>&gt; which(lisa %% 17 == 0)</pre>

<pre >## [1] 1 4</pre>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity-1">

<p>Write an expression using logical testing and indexing that, when applied to the vector <code>dummy</code>, returns the same output as the numeric indexing example shown below.</p>

<pre class = 'prettyprint lang-r'>&gt; dummy &lt;- 17:23
&gt; dummy[5:7]</pre>

<pre >## [1] 21 22 23</pre>

</article></slide><slide class=''><hgroup><h2>Testing Multiple Conditions</h2></hgroup><article  id="testing-multiple-conditions">

<p>Sometimes you need to select elements based on multiple conditions. For example, you might want to select only those values that are less than 4 standard deviations above or below the mean.</p>

<p>In R, we can select elements based on multiple conditions by combining individual logical tests together using <em>logical operators</em>. The logical operations we have at our disposal are:</p>

<ul>
<li>AND

<ul>
<li>Each element must meet <strong>all</strong> conditions to return <code>TRUE</code></li>
</ul></li>
<li>OR

<ul>
<li>Each element must meet <strong>at least one</strong> conditions to return <code>TRUE</code></li>
</ul></li>
<li>Negation

<ul>
<li>Reverse the current logical (e.g., <code>TRUE</code> becomes <code>FALSE</code>)</li>
</ul></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Logical Operators</h2></hgroup><article  id="logical-operators">

<table class = 'rmdtable'>
<tr class="header">
<th align="left">Logic</th>
<th align="left">Expression</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
<tr class="odd">
<td align="left">Elementwise AND</td>
<td align="left"><code>&amp;</code></td>
<td align="left"><code>c(1,3) &gt; 0 &amp; c(1,3) &lt;=2</code></td>
<td align="left">TRUE, FALSE</td>
</tr>
<tr class="even">
<td align="left">Scalar AND</td>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left"><code>3 &gt; 0 &amp;&amp; 3 &lt;=2</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="odd">
<td align="left">Elementwise OR</td>
<td align="left"><strong><code>|</code></strong></td>
<td align="left"><code>c(1,3) &gt; 0 | c(1,3) &lt;=2</code></td>
<td align="left">TRUE, TRUE</td>
</tr>
<tr class="even">
<td align="left">Scalar OR</td>
<td align="left"><strong><code>||</code></strong></td>
<td align="left"><code>3 &gt; 0 || 3 &lt;=2</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">Negate</td>
<td align="left"><code>!</code></td>
<td align="left"><code>!(3 &gt; 0)</code></td>
<td align="left">FALSE</td>
</tr>
</table>

<p>The elementwise operators test all their arguments (i.e., they test all the pairs elements of the logical vectors supplied) and return a vector the same length as the input.</p>

<p>The scalar operators only test the <em>first pair</em> of elements from their input, regardless of length, and return a single <code>TRUE</code> or <code>FALSE</code>. Thus, scalar operators should only be used for comparing a single value to another single value.</p>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions">

<p>Let&#39;s say we wanted to select the elements in <code>lisa</code> which were less than 500 or greater than 1000.</p>

<pre class = 'prettyprint lang-r'>&gt; lisa</pre>

<pre >## [1]   34  509   63  187  998   78 3330</pre>

<p>To do this, we need to:</p>

<ol>
<li>Test each element of <code>lisa</code> to see if it is less then 500

<ul>
<li><code>lisa &lt; 500</code></li>
</ul></li>
<li>Test each element of <code>lisa</code> to see if it is greater than 1000

<ul>
<li><code>lisa &gt; 1000</code></li>
</ul></li>
<li>Combine the results of both tests together into a single test

<ul>
<li>???</li>
</ul></li>
</ol>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-1" class="conditionals">

<p>Our goal of the test is to have it return a <code>TRUE</code> for each element if it passed the &quot;less than 500&quot; test <strong>OR</strong> if it passed the &quot;greater than 1000&quot; test.</p>

<table class = 'rmdtable'>
<col width="16%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<tr class="header">
<th align="left">Expression</th>
<th align="left">Element 1</th>
<th align="left">Element 2</th>
<th align="left">Element 3</th>
<th align="left">Element 4</th>
<th align="left">Element 5</th>
<th align="left">Element 6</th>
<th align="left">Element 7</th>
</tr>
<tr class="odd">
<td align="left"><code>lisa</code></td>
<td align="left">34</td>
<td align="left">509</td>
<td align="left">63</td>
<td align="left">187</td>
<td align="left">998</td>
<td align="left">78</td>
<td align="left">3330</td>
</tr>
<tr class="even">
<td align="left"><code>lisa &lt; 500</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
</tr>
<tr class="odd">
<td align="left"><code>lisa &gt; 1000</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
</tr>
<tr class="even">
<td align="left">Pass Either Test?</td>
<td align="left"><span style="color: Green">
✓</span></td>
<td align="left"><span style="color: Red">
✕ </span></td>
<td align="left"><span style="color: Green">
 ✓ </span></td>
<td align="left"><span style="color: Green">
 ✓ </span></td>
<td align="left"><span style="color: Red">
 ✕ </span></td>
<td align="left"><span style="color: Green">
 ✓ </span></td>
<td align="left"><span style="color: Green">
 ✓ </span></td>
</tr>
</table>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-2">

<p>Our goal of the test is to have it return a <code>TRUE</code> for each element if it passed the &quot;less than 500&quot;&quot; test <strong>OR</strong> if it passed the &quot;greater than 1000&quot;&quot; test.</p>

<p>We can do that by combining the two tests with the <code>|</code> logical operator</p>

<table class = 'rmdtable'>
<col width="16%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<tr class="header">
<th align="left">Expression</th>
<th align="left">Element 1</th>
<th align="left">Element 2</th>
<th align="left">Element 3</th>
<th align="left">Element 4</th>
<th align="left">Element 5</th>
<th align="left">Element 6</th>
<th align="left">Element 7</th>
</tr>
<tr class="odd">
<td align="left"><code>lisa</code></td>
<td align="left">34</td>
<td align="left">509</td>
<td align="left">63</td>
<td align="left">187</td>
<td align="left">998</td>
<td align="left">78</td>
<td align="left">3330</td>
</tr>
<tr class="even">
<td align="left"><code>lisa &lt; 500</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
</tr>
<tr class="odd">
<td align="left"><code>lisa &gt; 1000</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
</tr>
<tr class="even">
<td align="left"><code>lisa &lt; 500 | lisa &gt; 1000</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
</tr>
</table>

<p><br></p>

<pre class = 'prettyprint lang-r'>&gt; lisa[lisa &lt; 500 | lisa &gt; 1000]</pre>

<pre >## [1]   34   63  187   78 3330</pre>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-3">

<p>Now let&#39;s say we wanted to select the elements in <code>lisa</code> which were less than 100 and greater than or equal to 10.</p>

<p>To do this, we need to:</p>

<ul class = 'build'>
<li>Test each element of <code>lisa</code> to see if it is less then 100

<ul>
<li><code>lisa &lt; 500</code></li>
</ul></li>
<li>Test each element of <code>lisa</code> to see if it is greater than 1000

<ul>
<li><code>lisa &gt;= 50</code></li>
</ul></li>
<li>Combine the results of both tests together into a single test

<ul>
<li><code>&amp;</code></li>
</ul></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-4">

<p>Our goal of the test is to have it return a <code>TRUE</code> for each element if it passed the &quot;less than 500&quot; test <strong>AND</strong> if it passed the &quot;greater than 50&quot; test.</p>

<table class = 'rmdtable'>
<col width="16%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<tr class="header">
<th align="left">Expression</th>
<th align="left">Element 1</th>
<th align="left">Element 2</th>
<th align="left">Element 3</th>
<th align="left">Element 4</th>
<th align="left">Element 5</th>
<th align="left">Element 6</th>
<th align="left">Element 7</th>
</tr>
<tr class="odd">
<td align="left"><code>lisa</code></td>
<td align="left">34</td>
<td align="left">509</td>
<td align="left">63</td>
<td align="left">187</td>
<td align="left">998</td>
<td align="left">78</td>
<td align="left">3330</td>
</tr>
<tr class="even">
<td align="left"><code>lisa &lt; 500</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
</tr>
<tr class="odd">
<td align="left"><code>lisa &gt;= 50</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
</tr>
<tr class="even">
<td align="left"><code>lisa &lt; 500 &amp; lisa &gt;= 50</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left"><code>TRUE</code></td>
<td align="left"><code>FALSE</code></td>
</tr>
</table>

<p><br></p>

<pre class = 'prettyprint lang-r'>&gt; lisa[lisa &lt; 500 &amp; lisa &gt;= 50]</pre>

<pre >## [1]  63 187  78</pre>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-5">

<pre class = 'prettyprint lang-r'>&gt; lisa[lisa &lt; 500 &amp; lisa &gt;= 998]</pre>

<pre >## numeric(0)</pre>

<p>When you index any structure in R with a vector of all <code>FALSE</code>s, you get back <code>numeric(0)</code> which means &quot;nothing to see here!&quot;</p>

<p>So why does this test and subset return nothing? Because no number can be less than 500 and greater than 998, so every test comes back <code>FALSE</code>, and all elements are ignored in the subset.</p>

</article></slide><slide class=''><hgroup><h2>Exercise</h2></hgroup><article  id="exercise">

<ol>
<li><p>Use R to find all the numbers between 1 and 10,000 that are multiples of 2 or multiples of 3. How many are there?</p></li>
<li><p>Use R to find all the numbers between 1 and 10,000 that are multiples of both 2 and 3. How many are there?</p></li>
</ol></article></slide>


  <slide class="backdrop"></slide>

</slides>

<script src="lib/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
<script src="lib/ioslides-13.5.1/js/prettify/prettify.js"></script>
<script src="lib/ioslides-13.5.1/js/prettify/lang-r.js"></script>
<script src="lib/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
<script src="lib/ioslides-13.5.1/js/hammer.js"></script>
<script src="lib/ioslides-13.5.1/js/slide-controller.js"></script>
<script src="lib/ioslides-13.5.1/js/slide-deck.js"></script>


<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
