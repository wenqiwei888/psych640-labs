<!DOCTYPE html>
<html>
<head>
  <title>Manipulating Data Part 1: The Data Awakens</title>

  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />



  <meta name="date" content="2016-09-16" />

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <link rel="stylesheet" media="all" href="lib/ioslides-13.5.1/fonts/fonts.css">

  <link rel="stylesheet" media="all" href="lib/ioslides-13.5.1/theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="lib/ioslides-13.5.1/theme/css/phone.css">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'Manipulating Data Part 1: The Data Awakens',
                        useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                      },

      // Author information
      presenters: [
            {
        name:  'William Hopper' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }

  </style>

  <link rel="stylesheet" href="../theme/css/custom.css" type="text/css" />


</head>

<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
            <p style="margin-top: 6px; margin-left: -2px;">2016-09-16</p>
          </hgroup>
  </slide>

<slide class=''><hgroup><h2>Indexing</h2></hgroup><article  id="indexing">

<p>All throughout your data analysis pipeline, you will face the need to take smaller chunks out of a larger data structure. Sometimes you will need to change the data that is stored in your structure, or use it as input to another function, or perhaps you need to plot it.</p>

<p>The task of slicing a smaller chunk out of a larger data structure is called <strong>indexing</strong> in R (sometimes called <strong>subsetting</strong> depending on context), and is performed using the square bracket characters <code>[]</code>.</p>

</article></slide><slide class=''><hgroup><h2>Indexing &#39;Ingredients&#39;</h2></hgroup><article  id="indexing-ingredients">

<p>Indexing a data structure in R requires 4 ingredients.</p>

<ol>
<li>An R object that supports indexing

<ul>
<li>e.g. A data frame, matrix, vector or list</li>
</ul></li>
<li>An opening square bracket <code>[</code></li>
<li>1 (or more) vectors which indicate which values from the larger data structure should be pulled out.</li>
<li>a closing squre bracket <code>]</code></li>
</ol>

<p>Arrange the ingredients in an R expression like so:</p>

<p><code>DataStructure[IndexVector]</code></p>

<p>We will focus on learning what can go inside the square brackets for different types of R data structures</p>

</article></slide><slide class=''><hgroup><h2>Indexing Vectors</h2></hgroup><article  id="indexing-vectors">

<p>Broadly, there are 2 types of indexing vectors that can be put inside the square brackets.</p>

<ol>
<li>Numeric Vectors

<ul>
<li>e.g. <code>c(1,4,5,6,10)</code></li>
</ul></li>
<li>Logical Vectors

<ul>
<li>e.g. <code>c(TRUE,FALSE,FALSE,TRUE)</code></li>
</ul></li>
</ol>

<p>We&#39;ll start with numeric indexing vectors to get a feel for the general procedure, and move up to logical indexing.</p>

</article></slide><slide class=''><hgroup><h2>Numeric Index Vectors</h2></hgroup><article  id="numeric-index-vectors">

<p>Lets start with a large vector and break it down. The numeric vectors inside the brackets tell R the positions of the elements we wish to extract.</p>

<pre class = 'prettyprint lang-r'>alphabet &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,
              &quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) 
alphabet[c(1,26)] # Extract First and 26th element</pre>

<pre >## [1] &quot;a&quot; &quot;z&quot;</pre>

<pre class = 'prettyprint lang-r'>alphabet[10:20] # Extract tenth through 20th</pre>

<pre >##  [1] &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot;</pre>

<pre class = 'prettyprint lang-r'>alphabet[seq(from=1,to=26,by=2)] # Extract every other element</pre>

<pre >##  [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot;</pre>

</article></slide><slide class=''><hgroup><h2>Common Errors with Numeric Indices</h2></hgroup><article  id="common-errors-with-numeric-indices">

<p>The most common mistake is including a value in your indexing vector which is greater than the length of the vector you are subsetting</p>

<pre class = 'prettyprint lang-r'>alphabet[100] # there are not 100 letters in the alphabet</pre>

<pre >## [1] NA</pre>

<p>The <code>NA</code> means the value is missing. This is commonly referred to as an &quot;index out of bounds&quot; error.</p>

Another common mistake is forgetting to concatenate the values you want to slice out into a vector (i.e. forgetting the <code>c()</code> function)

<div class="errormsg">
<pre class = 'prettyprint lang-r'>alphabet[1,5,10]</pre>

<pre >## Error in alphabet[1, 5, 10]: incorrect number of dimensions</pre></div>

</article></slide><slide class=''><hgroup><h2>Indexing Tricks</h2></hgroup><article  id="indexing-tricks">

<p>Instead of creating a vector of values you <em>do</em> want to pick out, it may be easier to come up with a vector of ones you <em>don&#39;t</em> want. We can use negative number&#39;s to specify which vector elements we don&#39;t want.</p>

<pre class = 'prettyprint lang-r'>alphabet[c(-1,-26)] # Same as alphabet[2:24]</pre>

<pre >##  [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot;
## [18] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot;</pre>

<pre class = 'prettyprint lang-r'>alphabet[-1:-10]</pre>

<pre >##  [1] &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot;</pre>

<p>Indexing with positive vectors is usually prefered, as the intent of the code is more clear, but sometimes this is easier and more clear (e.g. when dropping the first or last value)</p>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity">

<p>Execute the following code and look at the values in <code>months</code>:</p>

<pre class = 'prettyprint lang-r'>months &lt;- c(&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
            &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;)
months</pre>

<pre >##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;      
##  [6] &quot;June&quot;      &quot;July&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;  
## [11] &quot;November&quot;  &quot;December&quot;</pre>

<p>Now, do the following:</p>

<ol>
<li>Index <code>months</code> to pull out <code>&quot;February&quot;</code> and <code>&quot;March&quot;</code></li>
<li>Index months to pull out third month</li>
</ol>

</article></slide><slide class=''><hgroup><h2>Logical Indexing</h2></hgroup><article  id="logical-indexing">

<p>You can perform indexing with logical vectors in the same fashion as numeric indexing - just make a vector of logicals and stick it in the square brackets after your vector.</p>

<p>But this is not a good use case for logical vectors. Why?</p>

<ol>
<li>Longer Code: length of the logical vector must match the length of the object its subsetting.</li>
<li>Duplicating work: If you already know the position of the elements you want, just put them into a vector and you&#39;re done!</li>
</ol>

<p>The logical vector&#39;s utility comes into play when you <em>don&#39;t</em> know the numeric positions of the elements you are interested in.</p>

</article></slide><slide class=''><hgroup><h2>Logical Indexing</h2></hgroup><article  id="logical-indexing-1">

<p>&quot;But wait&quot; you say: &quot;If we don&#39;t know where they are already, how are we going to find them?&quot;. This brings us to <strong>logical testing</strong> and <strong>relational operators</strong></p>

<p>Relational operators are R expressions that can be used to test whether or not some value meets a condition or not. If it meets your test&#39;s conditions, the test returns <code>TRUE</code>. If it does not, it returns <code>FALSE</code>.</p>

<p>You already know lots of relational operators. The equal to, greater than and less than expressions from 3rd grade math are all relational operators!</p>

</article></slide><slide class=''><hgroup><h2>Relational Operators Table</h2></hgroup><article  id="relational-operators-table">

<table class = 'rmdtable'>
<tr class="header">
<th align="left">Comparison</th>
<th align="left">Expression</th>
<th align="left">Example</th>
</tr>
<tr class="odd">
<td align="left">Less Than</td>
<td align="left"><code>&lt;</code></td>
<td align="left"><code>5 &lt; 10</code>, <code>5 &lt; 1</code></td>
</tr>
<tr class="even">
<td align="left">Less Than or Equal To</td>
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>5 &lt;= 5</code>, <code>5 &lt;= 1</code></td>
</tr>
<tr class="odd">
<td align="left">Greater Than</td>
<td align="left"><code>&gt;</code></td>
<td align="left"><code>10 &gt; 5</code>, <code>5 &gt; 5</code></td>
</tr>
<tr class="even">
<td align="left">Greater Than or Equal To</td>
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>10 &gt;= 10</code>, <code>10 &gt;= 12</code></td>
</tr>
<tr class="odd">
<td align="left">Equal To</td>
<td align="left"><code>==</code></td>
<td align="left"><code>5 == 6</code>, <code>5 == 5</code></td>
</tr>
<tr class="even">
<td align="left">Not equal to</td>
<td align="left"><code>!=</code></td>
<td align="left"><code>5 != 6</code>, <code>5 != 5</code></td>
</tr>
</table>

</article></slide><slide class=''><hgroup><h2>Relational Operators &amp; Indexing</h2></hgroup><article  id="relational-operators-indexing">

<p>What makes relational operators useful is that they can be applied to all the elements of a data structure simultaneously.</p>

<pre class = 'prettyprint lang-r'>x &lt;- 2:11
x &lt;= 5 # Apply the less than or equals test</pre>

<pre >##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE</pre>

<p>As you can see, values that meet the criteria (&lt;= 5) return as <code>TRUE</code>.</p>

<pre class = 'prettyprint lang-r'>x[x &lt;= 5] # Index vector x with the results of the test. </pre>

<pre >## [1] 2 3 4 5</pre>

<p>When this logical vector is used to index the vector <code>x</code>, only the elements where the logical vector has value <code>TRUE</code> are returned.</p>

</article></slide><slide class=''><hgroup><h2>Relational Operators &amp; Indexing</h2></hgroup><article  id="relational-operators-indexing-1">

<p>We index character vectors using the <code>==</code> and <code>!=</code> operators, but not the greater/less than operators. Quantity makes no sense for characters!</p>

<pre class = 'prettyprint lang-r'>months == &quot;June&quot; # The sixth element is TRUE</pre>

<pre >##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE</pre>

<pre class = 'prettyprint lang-r'>months[months == &quot;June&quot;]</pre>

<pre >## [1] &quot;June&quot;</pre>

<pre class = 'prettyprint lang-r'>months[months != &quot;July&quot;]</pre>

<pre >##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;      
##  [6] &quot;June&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;   &quot;November&quot; 
## [11] &quot;December&quot;</pre>

</article></slide><slide class=''><hgroup><h2>Other Useful Tests: <code>is.na()</code></h2></hgroup><article  id="other-useful-tests-is.na">

<p>Unfortunately, we often have to deal with missing observations in real world data sets. R codes missing data as <code>NA</code> (or sometimes <code>NaN</code>). We can use the <code>is.na()</code> function to find any missing values in a vector.</p>

<pre class = 'prettyprint lang-r'>missingno &lt;- c(10,NA,1,4,2,NA,NA,99,NaN, NA)
is.na(missingno)</pre>

<pre >##  [1] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE</pre>

<pre class = 'prettyprint lang-r'>missingno[!is.na(missingno)] # Select things that are the opposite of missing</pre>

<pre >## [1] 10  1  4  2 99</pre>

</article></slide><slide class=''><hgroup><h2>Other Useful Tests: modulus division</h2></hgroup><article  id="other-useful-tests-modulus-division">

<p>An important arithmetic operator that was not mentioned last week is the modulus operator <code>%%</code>, which gives us the remainder of division. For example: <code>5 %% 3</code> is <code>2</code>.</p>

<pre class = 'prettyprint lang-r'>lisa &lt;- c(1,34,5,63,209,11,17,998,78,3330)
lisa %% 17 == 0</pre>

<pre >##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE</pre>

<pre class = 'prettyprint lang-r'>lisa[lisa %% 17 == 0]</pre>

<pre >## [1] 34 17</pre>

<p>This returns all the values of the vector called <code>lisa</code> that are multiples of 17, since multiples of 17 will have a remainder of zero.</p>

</article></slide><slide class=''><hgroup><h2>Tips and Tricks</h2></hgroup><article  id="tips-and-tricks">

<p>A useful function to know is <code>which()</code>. When used on a logical vector, it will return to your the position indices of the vector&#39;s <code>TRUE</code> element. It is useful when you want to know <strong>where</strong> in the vector your matches occur.</p>

<pre class = 'prettyprint lang-r'>lisa %% 17 == 0</pre>

<pre >##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE</pre>

<pre class = 'prettyprint lang-r'>which(lisa %% 17 == 0)</pre>

<pre >## [1] 2 7</pre>

</article></slide><slide class=''><hgroup><h2>Activity</h2></hgroup><article  id="activity-1">

<p>Write an expression using logical testing and indexing that, when applied to the vector <code>dummy</code>, returns the same output as the numeric indexing example shown below.</p>

<pre class = 'prettyprint lang-r'>dummy &lt;- 17:23
dummy[5:7]</pre>

<pre >## [1] 21 22 23</pre>

</article></slide><slide class=''><hgroup><h2>Testing Multiple Conditions</h2></hgroup><article  id="testing-multiple-conditions">

<p>Sometimes you need to test multiple conditions, for example, perhaps you need to pick only values within a certain range to exclude some outliers. This neccesitates that we combine multiple logical tests in order to pull out only values that meet at least one or all of our requirements.</p>

<p>Luckily, we have logical operators around to help use chain our comparisons together! The logical operations we have at our disposal are:</p>

<ul>
<li>AND: <strong>Both</strong> Conditions must be met to return TRUE</li>
<li>OR: <strong>Either</strong> condition can be met to return TRUE</li>
<li>negation: Reverse the current logical (TRUE becomes FALSE)</li>
</ul>

</article></slide><slide class=''><hgroup><h2>Logical Operators</h2></hgroup><article  id="logical-operators">

<table class = 'rmdtable'>
<tr class="header">
<th align="left">Logic</th>
<th align="left">Expression</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
<tr class="odd">
<td align="left">Elementwise AND</td>
<td align="left"><code>&amp;</code></td>
<td align="left"><code>c(1,3) &gt; 0 &amp; c(1,3) &lt;=2</code></td>
<td align="left">TRUE, FALSE</td>
</tr>
<tr class="even">
<td align="left">Scalar AND</td>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left"><code>3 &gt; 0 &amp; 3 &lt;=2</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="odd">
<td align="left">Elementwise OR</td>
<td align="left"><strong><code>|</code></strong></td>
<td align="left"><code>c(1,3) &gt; 0 | c(1,3) &lt;=2</code></td>
<td align="left">TRUE, TRUE</td>
</tr>
<tr class="even">
<td align="left">Scalar OR</td>
<td align="left"><strong><code>||</code></strong></td>
<td align="left"><code>3 &gt; 0 | 3 &lt;=2</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">Negate</td>
<td align="left"><code>!</code></td>
<td align="left"><code>!(3 &gt; 0)</code></td>
<td align="left">FALSE</td>
</tr>
</table>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions">

<p>Lets bring back our old friend <code>lisa</code> to try out some examples of multiple conditionals.</p>

<pre class = 'prettyprint lang-r'>lisa[lisa &lt; 500 | lisa &gt; 1000]</pre>

<pre >## [1]    1   34    5   63  209   11   17   78 3330</pre>

<p>The logical tests inside the brackets test to see whether each number in <code>lisa</code> is less than 500 <strong>OR</strong> greater than or equal to 998.<code>lisa</code> has more than one element,so we use a single <strong><code>|</code></strong>.</p>

<p>This produces a logical vector with <code>TRUE</code> in the position of items that meet the test criteria, and a <code>FALSE</code> in the position of items that don&#39;t.</p>

<p>Then, the square brackets subset <code>lisa</code> using this logical vector, returning the values where it is <code>TRUE</code>.</p>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-1">

<pre class = 'prettyprint lang-r'>lisa[lisa &lt; 100 &amp; lisa &gt;= 10]</pre>

<pre >## [1] 34 63 11 17 78</pre>

<p>This test selects for 2-digit numbers - those between 10 and 100. For the test to return <code>TRUE</code>, it must be both greater than or equal to 10, <strong>AND</strong> less than 100.</p>

</article></slide><slide class=''><hgroup><h2>Indexing with Multiple Conditions</h2></hgroup><article  id="indexing-with-multiple-conditions-2">

<pre class = 'prettyprint lang-r'>lisa[lisa &lt; 500 &amp; lisa &gt;= 998]</pre>

<pre >## numeric(0)</pre>

<p>When you index any structure in R with a vector of all <code>FALSE</code>s, you get back <code>numeric(0)</code> which means &quot;nothing to see here!&quot;</p>

<p>So why does this test and subset return nothing? Because no number can be less than 500 and greater than 998, so every test comes back <code>FALSE</code>, and all elements are ignored in the subset.</p>

</article></slide><slide class=''><hgroup><h2>Exercise</h2></hgroup><article  id="exercise">

<ol>
<li><p>Use R to find all the numbers between 1 and 10,000 that are multiples of 2 or multiples of 3. How many are there?</p></li>
<li><p>Use R to find all the numbers between 1 and 10,000 that are multiples of both 2 and 3. How many are there?</p></li>
</ol></article></slide>


  <slide class="backdrop"></slide>

</slides>

<script src="lib/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
<script src="lib/ioslides-13.5.1/js/prettify/prettify.js"></script>
<script src="lib/ioslides-13.5.1/js/prettify/lang-r.js"></script>
<script src="lib/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
<script src="lib/ioslides-13.5.1/js/hammer.js"></script>
<script src="lib/ioslides-13.5.1/js/slide-controller.js"></script>
<script src="lib/ioslides-13.5.1/js/slide-deck.js"></script>


<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
